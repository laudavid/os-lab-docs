# 一、实验思考题

## Thinking 5.1

> 查阅资料，了解Linux/Unix 的/proc 文件系统是什么？有什么作用？Windows 操作系统又是如何实现这些功能的？proc 文件系统这样的设计有什么好处和可以改进的地方？

/proc文件系统是LINUX/UNIX系统上的一种伪文件系统（虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，仅存在于内存中。其作用是为用户提供了一组和内核数据信息进行交互、获取有关系统硬件和进程的详细信息、在运行中通过改变内核参数来改变内核运行状态的接口。Windows系统下用户模式通过Win32 API函数（如ReadFile）来完成与内核模式的交互。这样的设计将对内核信息的访问交互抽象成了对文件的访问修改，从而简化了交互过程，提高了系统的安全性和稳定性。

## Thinking 5.2

> 如果我们通过kseg0读写设备，我们对于设备的写入会缓存到Cache中。通过kseg0访问设备是一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请你思考：这么做这会引起什么问题？对于不同种类的设备（如我们提到的串口设备和IDE磁盘）的操作会有差异吗？可以从缓存的性质和缓存刷新的策略来考虑。

对cache的写入操作可以分为“穿通过”(Write-Through)模式和“写回”(Write-Back)模式。对于写回模式而言，每次写入高速缓存时并不会更新内存，只有cache发生替换时才会更新内存，但我们访问设备时对设备的连续多次写入可能因为缓存没有及时刷新而发生覆盖，从而导致访问设备出错。对于不同种类的设备（如我们提到的串口设备和IDE 磁盘）的操作可能会有差异，如对于串口设备，设备的输入和输出可能因为缓存未及时刷新而被遗漏，对于IDE 磁盘，可能因为缓存未及时刷新而获得完全错误的内容。

## Exercise 5.2

> 文件系统需要负责维护磁盘块的申请和释放，在回收一个磁盘块时，需要更改`bitmap`中的标志位。如果要将一个磁盘块设置为free，只需要将bitmap中对应的bit的值设置为0x1即可。请完成`fs/fs.c`中的`free_block`函数，实现这一功能。同时思考为什么参数`blockno`的值不能为0？

根据指导书，blockno为0的磁盘块存储的内容为Boot Sector and Partition table，被作为启动扇区和分区表使用，所以不可以被free。

## Thinking 5.3

> 一个Block 最多存储1024 个指向其他磁盘块的指针，试计算，我们的文件系统支持的单个文件的最大大小为多大？

1024*4KB=4MB，在不使用间接磁盘块的前十个指针的前提下，文件系统支持的单个文件的最大大小为4MB。

## Thinking 5.4

> 查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制块？一个目录最多能有多少个子文件？

由`include/mmu.h`以及`include/fs.h`文件中的相关宏定义：

```c
#define BY2PG           4096            // bytes to a page
#define BY2BLK          BY2PG
#define BY2FILE         256
#define FILE2BLK        (BY2BLK/sizeof(struct File))
```

可知一个磁盘块中最多能存储FILE2BLK = 4096/256 = 16个文件控制块。

在不使用间接磁盘块的前十个指针的前提下，一个目录最多指向1024个磁盘块，每个磁盘块下面最多有16个文件控制块，所以一个目录最多有1024*16 = 16384个子文件。

## Thinking 5.5

> 请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？

根据fs.h中的宏定义：

```c
/* Maximum disk size we can handle (3GB) */
#define DISKMAX         0xc0000000
```

可知我们实验使用的内核支持的最大磁盘大小是3GB。

## Thinking 5.6

> 阅读`user/file.c `中的众多代码，发现很多函数中都会将一个`struct Fd`型的指针转换为`struct Filefd * `型的指针，请解释为什么这样的转换可行。

由fd.h文件中的内容：

```c
struct Fd {
        u_int fd_dev_id;
        u_int fd_offset;
        u_int fd_omode;
};
struct Filefd {
        struct Fd f_fd;
        u_int f_fileid;
        struct File f_file;
};
```

可以看出`Filefd`结构体包含了`Fd`结构体的信息，其第一个成员`f_fd`即为`Fd`结构体。

在最初打开一个文件时，对应的文件描述符被分配了一页的空间，保存`Fd`结构体的相关信息，然后`fsipc_open`函数在`Fd`结构体后设置包括`f_fileid`以及`File`结构体等各种信息。由于结构体的内存位置分配原则，该页面从前到后依次保存了Fd结构体，`f_fileid`，`File`结构体的相关信息，所以只需要`struct Fd`型的指针转换为`struct Filefd * `型的指针，就能通过它获取到文件的其他信息。

## Thinking 5.7

> 请解释`File`, `Fd`, `Filefd`, `Open `结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架。

```c
struct File { //文件控制块，用来描述和管理文件的基本信息，文件系统在访问文件或目录时会将其装入到内存并将其作为文件的“指针”使用；对应磁盘上的物理实体；
        u_char f_name[MAXNAMELEN];      // 文件名
        u_int f_size;                   // 文件大小
        u_int f_type;                   // 文件类型
        u_int f_direct[NDIRECT]; //10个直接指针，记录文件的前10个数据块在磁盘上的位置
        u_int f_indirect; //1个间接指针，指向一个间接磁盘块，文件磁盘块多于10时，该磁盘块存储文件的其他数据块在磁盘上的位置
        struct File *f_dir;             //指向文件所在目录的文件控制块
        u_char f_pad[BY2FILE - MAXNAMELEN - 4 - 4 - NDIRECT * 4 - 4 - 4]; //用来占位，使文件控制块的大小正好等于BY2FILE(256)
};

struct Fd {//文件描述符，存储文件的基本信息和用户进程中关于文件的状态，描述用户对于文件操作；打开文件时单独分配一页保存Fd的信息，用户进程在访问文件或目录时会多次用到该结构体；单纯的内存数据；
        u_int fd_dev_id; //设备id，在文件系统中为'f'
        u_int fd_offset; //页面中保存的文件数据的起始地址相对于该页面的偏移
        u_int fd_omode; //描述用户进程对文件的操作类型
};

struct Filefd {//增强版文件描述符，用户进程与文件系统服务进程通信时，文件系统会在原Fd结构体的后面补充f_fileid和f_file，所以用户进程可以将Fd结构体直接强制转换为Filefd结构体使用，用户进程在访问文件或目录时会多次用到该结构体；单纯的内存数据；
        struct Fd f_fd; //对应文件的原文件描述符
        u_int f_fileid;  //文件系统为打开的文件进行的编号，等于o_fileid
        struct File f_file; //对应文件的文件控制块
};

struct Open { //文件系统用来保存已打开的文件信息；仅供文件系统进程使用；单纯的内存数据；
    struct File *o_file;    // 指向该文件的文件控制块的指针
    u_int o_fileid;  // 文件系统为打开的文件进行的编号
    int o_mode;  //描述用户进程对文件的操作类型
    struct Filefd *o_ff;    //该文件的文件描述符在文件系统进程中的虚拟地址
};
```

## Thinking 5.8

> 阅读`serve`函数的代码，我们注意到函数中包含了一个死循环`for (;;) {...}`，为什么这段代码不会导致整个内核进入panic状态？

因为在`serve`函数中对于每种请求，都调用了相关的`serve_x`函数，而`serve_x`函数中会调用`ipc_send`函数，而`ipc_send`函数又会调用`syscall_yield`函数来切换进程，因此`serve`中的死循环不会使CPU一直阻塞，所以不会导致整个内核进入panic状态。

# 二、实验难点

# 三、体会与感想

# 四、指导书反馈

本次实验的指导书中笔误的地方较多，虽然5月31号更新的指导书对许多地方的错误进行了更正，但仍有少数地方存在疑问，如第118页：

> 我们的操作系统内核中，之前的**操作钟**，将物理内存转换为内核虚拟地址，都是转换到kseg0 段的内核虚拟地址。使用的是KADDR宏，也就是将物理地址加上ULIM的值(0x80000000)。而正如我们上面提到的，编写设备驱动的时候我们需要将物理地址转换为kseg1 段的内核虚拟地址，也就是将物理地址加上kseg1 的偏移值(0xA0000000)。

此处“操作钟”似乎应为“操作中”

第125页：

> 我们使用的操作系统内核中，文件名的最大长度为MAXNAMELEN(128)，每个文件控制块设有10 个直接指针，用来记录文件的数据块在磁盘上的位置。每个磁盘块的大小为4KB，也就是说，这十个直接指针能够表示最大40KB 的文件，而当文件的大小大于40KB 时，就需要用到间接指针。File 结构体中有一个域为f_indirect，**只想**一个间接磁盘块，用来存储指向文件内容的磁盘块的指针。为了简化计算，我们不使用间接磁盘块的前十个指针。文件控制块的结构如图5.3。

此处“只想”应该为“指向”。

第126页：

>Exercise 5.5 fs/fs.c 中的diskaddr 函数用来计算指定磁盘块对应的虚存地址。完成diskaddr 函数，根据一个块的序号(block number)，计算这一磁盘块对应的512bytes 虚存的起始地址。（提示：fs/fs.h 中的宏DISKMAP 和DISKMAX 定义了磁盘映射虚存的地址空间）

此处一个磁盘块的大小应为4KB，为什么对应的是512bytes，一个扇区的大小？

