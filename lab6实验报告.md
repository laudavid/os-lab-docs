# 一、实验思考题

## Thinking 6.1

> 示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想让父进程作为“读者”，代码应当如何修改？
>

只需要交换代码中的第24行`case 0:`和第32行`default:`的位置即可，让父进程关闭写端，操作读端，子进程关闭读端，操作写端。

## Thinking 6.2

> 上面这种不同步修改pp_ref 而导致的进程竞争问题在user/fd.c中的dup函数中也存在。请结合代码模仿上述情景，分析一下我们的dup函数中为什么会出现预想之外的情况？
>

dup函数将一个文件描述符对应的内容映射到另一个文件描述符。假设我们将一个管道的读端或写端对应的文件描述符（如fd[0]）映射到另一个文件描述符（如文件描述符编号为0，对应标准输入文件），映射之前fd[0]，fd[1]和pipe的引用次数分别为1，1，2。按dup函数的执行顺序，会先将fd[0]的引用次数加1，然后将pipe的引用次数加1，如果fd[0]的引用次数加1后恰好发生时钟中断，然后跳转到另一进程调用_pipeisclosed函数判断管道写端是否关闭，由于pageref(p[0]) == pageref(pipe) == 2，故误认为写端关闭，导致出现判断错误。

## Thinking 6.3

> 阅读上述材料并思考：为什么系统调用一定是原子操作呢？如果你觉得不是所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析。
>

在我们的小操作系统中，进行系统调用陷入内核态时会进行屏蔽中断的操作，系统调用执行完成后才会解除中断屏蔽，所以执行系统调用函数的相关代码时不会受到时钟中断等因素的影响而被打断，所以进行系统调用一定是原子操作。

用于屏蔽中断位的设置的汇编宏：

```C
.macro CLI
        mfc0    t0, CP0_STATUS
        li      t1, (STATUS_CU0 | 0x1)
        or      t0, t1
        xor     t0, 0x1
        mtc0    t0, CP0_STATUS
.endm
```

但是在Unix/Linux中并不是所有的系统调用都是原子操作，如write系统调用就可以被打断。

而且上面说的仅针对单核的情况，如果是多核的环境中，单纯的屏蔽中断，无法保证系统调用为原子操作，比如屏蔽了这个cpu的中断，其他的cpu运行的进程依然可以执行内存读写的操作。

## Thinking 6.4

> 仔细阅读上面这段话，并思考下列问题
>
> - 按照上述说法控制pipeclose 中fd 和pipe unmap 的顺序，是否可以解决上述场景的进程竞争问题？给出你的分析过程。
> - 我们只分析了close 时的情形，那么对于dup 中出现的情况又该如何解决？请模仿上述材料写写你的理解。

（1）可以解决上述场景的进程竞争问题。因为正常情况下pipe的引用次数总比fd要高，所以先对fd的引用次数减1，再对pipe的引用次数减1，这样在任何时候发生中断时pipe的引用次数都要大于fd的引用次数，不会出现二者相等的情况，也就不会造成对管道是否关闭的误判。

（2）dup函数执行时正常情况下pipe的引用次数总比fd要高，所以先对pipe的引用次数加1，再对fd的引用次数加1，这样在任何时候发生中断时pipe的引用次数都要大于fd的引用次数，不会出现二者相等的情况，也就不会造成对管道是否关闭的误判。

## Thinking 6.5

> 请解释spawn函数中注释标记为Share memory 一段的作用，并说明为什么该段代码是正确的。你可以尝试对该段代码进行改动以探究其对运行结果的影响。
>

这段代码将父进程地址空间中带有PTE_LIBRARY的有效页面都映射到子进程的对应地址空间。

函数在访问页表之前会先判断页目录中对应页表项的有效性，页目录中页表项有效时才会进一步访问对应页表，且在用户态下通过\*vpd数组和\*vpt数组访问页目录和页表项，通过syscall_mem_map系统调用来映射地址空间，不会直接访问内核地址空间，所以是正确的。

# 二、实验难点

# 三、体会与感想

# 四、指导书反馈

 