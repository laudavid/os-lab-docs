# 一、实验思考题

## Thinking 2.1

> 请思考cache用虚拟地址来查询的可能性，并且给出这种方式对访存带来的好处和坏处。另外，你能否能根据前一个问题的解答来得出用物理地址来查询的优势?
>

（1）直接用虚拟地址来查询cache是不可取的，不同的进程可能拥有相同的虚拟地址。

（2）好处是可以直接根据虚拟地址查找cache中的数据而不用先通过mmu转化物理地址；坏处是不同的进程可能拥有相同的虚拟地址，可能会访问到同一个cache，这时候还要在cache中引入物理地址或其他标识符加以区分，同时不同的虚拟地址可能拥有相同的物理地址，这样在cache中就会存在重复，浪费资源。

（3）用物理地址来查询的优势在于查询时不需要对不同的进程加以区分，同时也避免了不同的虚拟地址指向相同的物理地址时产生的浪费。

## Thinking 2.2

> 请查阅相关资料，针对我们提出的疑问，给出一个上述流程的优化版本，新的版本需要有更快的访存效率。（提示：考虑并行执行某些步骤）
>

（1）将TLB查询页表项和MMU的页表查询工作并行执行，若TLB命中则终止另一个查询；

（2）将cache中查询数据和内存中查询数据并行执行，若cache命中则终止内存查询。

## Thinking 2.3

> 我们注意到我们把宏函数的函数体写成了do { /* ... \*/ } while(0)的形式，而不是仅仅写成形如{/* ... */ } 的语句块，这样的写法好处是什么？
>

对于一些没有返回值的宏函数，我们将其作为一条单独的语句使用时通常会在结尾加分号，这样使用在某些特殊情况下会产生很难发现的语法错误，用do{...}while(0)的形式，可以避免这些错误的发生。例如对于下面的程序：

```c
#include <stdio.h>
#define printNum(a, b) \
{                   \
    printf("%d ", a);         \
    printf("%d\n", b);      \
}
int main()
{
    int a=1,b=2;
    if(a<b)
        printNum(a,b);
    else
        printNum(b,a);
    
	return 0;
}
```

在编译的时候这个程序会报错，我们将宏函数展开带入到main()函数中：

```c
#include <stdio.h>
int main()
{
    int a=1,b=2;
    if(a<b)
	{                   
    	printf("%d ", a);         
    	printf("%d\n", b);      
	};
    else
    {                   
    	printf("%d ", b);         
    	printf("%d\n", a);      
	};
    
	return 0;
}
```

 可以发现if语句块大括号后的分号导致了语法错误。如果将宏函数用do{...}while(0)的形式进行替换，则不会产生编译错误：

```c
#include <stdio.h>
int main()
{
    int a=1,b=2;
    if(a<b)
		do{                   
    		printf("%d ", a);         
    		printf("%d\n", b);      
		}while(0);
    else
    	do{  
    		printf("%d ", b);         
    		printf("%d\n", a);      
		}while(0);
    
	return 0;
}
```

 由以上代码可以看出当将宏函数用于条件判断后的执行语句时要特别注意，否则可能产生不易察觉的语法错误，而do{...}while(0)则可以避免这类问题。

## Thinking 2.4

>  注意，我们定义的Page 结构体只是一个信息的载体，它只代表了相应物理内存页的信息，它本身并不是物理内存页。那我们的物理内存页究竟在哪呢？Page结构体又是通过怎样的方式找到它代表的物理内存页的地址呢？请你阅读include/pmap.h 与mm/pmap.c 中相关代码，给出你的想法。
>

（1）实际的物理内存页存在于真实的物理内存中，需要注意的是物理内存中内存是连续的，并非一页一页分离开来，所谓的物理内存页只是为方便内存管理而将物理内存地址按一定大小进行划分得到。

（2）通过include/pmap.h中的page2pa()函数可以知道只需要将物理页框号（某一Page结构体指针相对于pages指针的偏移）左移12位即可得到对应的物理内存页的物理地址。

## Thinking 2.5 

> 在mmu.h 中定义了bzero(void *b, size_t)这样一个函数, 请你思考，此处的b指针是一个物理地址，还是一个虚拟地址呢？
>

通过alloc(）函数中对于bzero()的调用可以知道，此处的b指针是一个虚拟地址，因为本身freemem是一个虚拟地址。

## Thinking 2.6

> 了解了二级页表页目录自映射的原理之后，我们知道，Win2k内核的虚存管理也是采用了二级页表的形式，其页表所占的4M 空间对应的虚存起始地址为0xC0000000，那么，它的页目录的起始地址是多少呢？
>

0xC0000000+((0xC0000000>>12)<<2) = 0xC0000000+0x00300000 = 0xcC0300000，所以页目录起始地址为0xc0300000。

## Thinking 2.7

> 思考一下tlb_out 汇编函数，结合代码阐述一下跳转到NOFOUND的流程？

首先将CP0_ENTRYHI寄存器中的内容暂时保存到k1寄存器中，然后将保存在a0寄存器中的参数即虚拟地址移动到CP0_ENTRYHI寄存器中，接下来调用tlpb指令，查询快表中是否有值为CP0_ENTRYHI的项，如果有则将其位置保存到CP0_INDEX中，如果没有则把CP0_INDEX高位置为1，然后取出CP0_INDEX寄存器中的值判断是否找到，如果此值小于0说明没有找到，通过bltz指令跳转到NOFOUND，如果找到则将CP0_ENTRYHI和CP0_ENTRYLO0寄存器置为0，使用tlbwi指令将CP0_ENTRYHI和CP0_ENTRYLO0写入快表中CP0_INDEX指向的位置。

## Thinking 2.8

> 显然，运行后结果与我们预期的不符，va 值为0x88888，相应的pa
> 中的值为0。这说明我们的代码中存在问题，请你仔细思考我们的访存模型，指出
> 问题所在。

va2pa函数所计算得到物理地址为va所在的物理页的物理地址，并没有加上页内偏移量。

# 二、实验难点

# 三、体会与感想

# 四、指导书反馈
