# 一、实验思考题

## Thinking 3.1

> 为什么我们在构造空闲进程链表时必须使用特定的插入顺序？(顺序或者逆序)
>

注释中写到：

>  Insert in the correct order, so that the first call to env_alloc() return the correct item of envs[].

我们每次都使用LIST_INSERT_HEAD宏将env控制块插入到链表的头部，所以只有使用特定的插入顺序进行插入，才能保证调用env_alloc()函数从env_free_list中取出env控制块时按照相反的顺序进行取出，但似乎即使不按顺序取出对进程的调度也不会有影响。

## Thinking 3.2

> 思考env.c/mkenvid函数和envid2env函数:
>
> - 请你谈谈对mkenvid函数中生成id的运算的理解，为什么这么做？
>
> - 为什么envid2env中需要判断e->env_id != envid 的情况？如果没有这步判断会发生什么情况？

（1）envid的低10位存储的是env在envs数组中的位置信息（相对于envs[0]的偏移），便于envid2env通过envid找到该id对应的进程控制块；高21位存储的则是一个增长的数字，大小等于mkenvid函数的调用次数，用来保证每次生成的envid是独一无二的。

（2）由mkenvid函数可知，对于数组envs中相同位置的env控制块，调用多次mkenvid生成的envid可能是不同的。也就是说，由envid的低11位在数组envs找到该id对应的进程控制块后，并不能确定该env控制块等于envid对应的控制块，需要进一步比较envid的高位信息是否相同。如果没有比较则可能该envid对应的env控制块并不存在但函数仍然返回了相关的env控制块信息，得到错误的结果。

## Thinking 3.3

> 结合include/mmu.h 中的地址空间布局，思考env_setup_vm 函数：
>
> - 我们在初始化新进程的地址空间时为什么不把整个地址空间的pgdir 都清零，而是复制内核的boot_pgdir作为一部分模板？(提示:mips 虚拟空间布局)
>
>
> - UTOP 和ULIM 的含义分别是什么，在UTOP 到ULIM 的区域与其他用户区相比有什么最大的区别？
>
>
> - 在step4 中我们为什么要让pgdir[PDX(UVPT)]=env_cr3?(提示: 结合系统自映射机制)
>
>
> - 谈谈自己对进程中物理地址和虚拟地址的理解
>

（1）对于每个进程来说，UTOP以上的虚拟地址空间对于不同的进程都有相同的映射，ULIM地址以上的部分属于内核态的虚拟地址，复制内核的boot_pgdir到新进程的pgdir，可以使新进程方便地切换到内核态下运行，而不用改变cr3寄存器的值。

（2）ULIM=0x80000000是操作系统分配给用户的2G地址空间的最大值，UTOP=0x7f400000，是用户能够自由读写的地址空间的最大值。UTOP到ULIM这段空间映射的是记录页面使用情况的4M大小的pages数组，4M进程控制块envs数组和用户页表域的那4M虚拟空间，用户不能写只能读，是在映射过程中留出来给用户进程查看其他进程信息的，用户在此处读取不会陷入异常。

（3）根据虚拟内存的自映射机制，页目录中有一项应该映射到页目录本身所在的物理地址，这个物理地址即为env_cr3，这一项在页目录中所在的位置应该为PDX(UVPT)，这样当我们给出一个属于User VPT域(UVPT ~ UVPT+4M)的虚拟地址时，进行虚拟到物理地址转换时，就会找到用户进程页目录的物理地址。

（4）对于不同的进程来说。每个进程都有着各自独立的虚拟地址空间，这样进程切换时不同的进程对相同的虚拟地址空间进行访问时互不影响，同时也扩大了每个进程的地址访问空间；物理地址则对应物理内存，不同的进程公用物理地址空间，不同的虚拟地址空间可能映射到相同的物理地址空间。

## Thinking 3.4

> 思考user_data 这个参数的作用。没有这个参数可不可以？为什么？（如果你能说明哪些应用场景中可能会应用这种设计就更好了。可以举一个实际的库中的例子）
>

不可以。我们在使用load\_icode\_mapper、load\_icode、load\_elf这三个函数时，这三个函数都是对同一个进程的操作，在load\_icode\_mapper函数中申请物理页面，把二进制镜像复制到一个个物理页面，最后还要使用page\_insert函数将这些页面填充到进程的页表项中，这时就需要把进程控制块相关的数据结构env传入函数中去。

这个参数的类型为void \*，可以传入任何类型的指针，load\_elf函数与C语言标准库函数中的qsort函数十分相似，void* base参数同样可以传入任何类型的指针，最后一个参数传入的参数也是一个函数。

```c
void qsort(void* base,size_t num,size_t width,int(__cdecl* compare)(const void*,const void*));
```

## Thinking 3.5

> 结合load_icode_mapper 的参数以及二进制镜像的大小，考虑该函数可能会面临哪几种复制的情况？你是否都考虑到了？
>

复制第一页是要考虑va的页内偏移量是否为0,，不为0的话复制到物理页面时要从页面起始地址加上页内偏移量开始复制，同时也要考虑复制的镜像大小是否可以填充满这个页面，不能的话该物理页的剩余部分应该用0填充。

复制第二页以后的页面到物理页面时都从页面起始地址开始复制，同时也要考虑剩余需要复制的镜像大小是否可以填充满这个页面，不能的话该物理页的剩余部分最好也用0填充。

镜像复制完成后也要考虑该段在文件中的内容的大小是否到该段在内存中所应有的大小，没有达到的话余下的部分也需要申请页面并用0来填充。

## Thinking 3.6

> 思考上面这一段话，并根据自己在lab2 中的理解，回答：
>
> - 我们这里出现的“指令位置”的概念，你认为该概念是针对虚拟空间，还是物理内存所定义的呢？
>
> - 你觉得entry_point其值对于每个进程是否一样？该如何理解这种统一或不同？

（1）是虚拟地址空间，二进制镜像被复制到了一个个物理页面，这些页面可能是分散的，但虚拟地址是连续的，指令顺序执行时每次pc+4，不关注页面是否分散，所以应是虚拟地址空间。

（2）是一样的。因为每个进程都是相互独立的进程，entry_point 的值是连接器写在 ELF 文件里的，而连接器是根据 linker script 确定这个值，ELF文件形成时entry_point已经确定，这里的entry_point记录的是虚拟地址，在真正执行的时候由于进程间切换时会改变cr3寄存器来改变页目录的物理地址，不同进程页表信息的不同，最终所映射到的物理地址也就不一样。

## Thinking 3.7

> 思考一下，要保存的进程上下文中的env_tf.pc的值应该设置为多少？为什么要这样设置？
>

首env\_tf.pc的地址应该设置为cp0\_epc的位置。进程切换时当前进程处于中断状态，这个进程在再次被恢复执行的时候， 应该从导致中断异常的那条指令开始继续执行，而异常返回地址记录在cp0\_epc寄存器中。

## Thinking 3.8

> 思考TIMESTACK 的含义，并找出相关语句与证明来回答以下关于TIMESTACK 的问题：
>
> - 请给出一个你认为合适的TIMESTACK 的定义
>
> - 请为你的定义在实验中找出合适的代码段作为证据(请对代码段进行分析)
>
> - 思考TIMESTACK 和第18 行的KERNEL_SP 的含义有何不同

（1）TIMESTACK是系统在发生时钟中断异常时保存现场所用的栈指针，TIMESTACK以下sizeof(struct Trapframe)大小的空间保存了当前发生中断的进程的上下文信息。

（2）在include/stackframe.h中，SAVE_ALL宏函数用于保存现场，该宏又调用了get_sp宏来设置栈指针：

```mips
.macro SAVE_ALL
1:
    move k0, sp
    get_sp
    move k1, sp
    subu sp, k1, TF_SIZE

.macro get_sp
    mfc0 k1, CP0_CAUSE
    andi k1, 0x107C
    xori k1, 0x1000
    bnez k1, 1f
    nop
    li sp, 0x82000000
    j 2f
    nop
1:
    bltz sp, 2f
    nop
    lw sp, KERNEL_SP
    nop
2:
    nop
.endm
```

在get_sp宏中，如果CP0_CAUSE寄存器的exception code为0且4号中断位为1，即当前是4号中断导致的异常，则获取的sp就是0x82000000，也就是TIMESTACK的值，如果exception code非0，那么获取的sp是存储在KERNEL_SP中的内核栈指针。发生中断时执行get_sp函数将sp设为了TIMESTACK，然后sp减去Trapframe的大小，以此为基址，保存当期进程的上下文。

（3）KERNEL_SP是产生非时钟中断异常时所用到的栈指针，TIMESTACK则是发生时钟中断异常时用到的栈指针。

## Thinking 3.9

> 思考一下你的调度程序，为什么输出1 的个数不是恰好2 的个数的2倍。
>
> - 有什么因素会导致这种情况？
>
> - 有什么办法能避免这种情况？

（1）因为进程调度的过程会存在一定的时间误差，进程的调度过程本身会占用一定的时间。

（2）这似乎是无法避免的，只能采用更加高效的调度方法，尽力减小这种误差。

# 二、实验难点

# 三、体会与感想

# 四、指导书反馈





 

